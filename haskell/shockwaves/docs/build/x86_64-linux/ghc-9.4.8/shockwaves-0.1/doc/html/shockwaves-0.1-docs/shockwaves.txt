-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package shockwaves
@version 0.1


-- | Module containing some simple color functionality for custom signal
--   colors.
module Shockwaves.Color

-- | Simple RGB representation used for custom signal colors.
data Color
RGB :: Word8 -> Word8 -> Word8 -> Color

-- | #ff0000
red :: Color

-- | #ffff00
yellow :: Color

-- | #00ff00
green :: Color

-- | #00ffff
cyan :: Color

-- | #0000ff
blue :: Color

-- | #ff00ff
magenta :: Color

-- | #ffffff
white :: Color

-- | #7f7f7f
gray :: Color
instance Clash.XException.NFDataX Shockwaves.Color.Color
instance Control.DeepSeq.NFData Shockwaves.Color.Color
instance GHC.Generics.Generic Shockwaves.Color.Color
instance GHC.Show.Show Shockwaves.Color.Color


-- | Module containing the main translation classes and implementations for
--   Shockwaves.
--   
--   The behaviour of this module can be changed using several flags:
--   
--   <ul>
--   <li><tt>left-err</tt> (display the <a>Left</a> variant of
--   <a>Either</a> as an error)</li>
--   <li><tt>nothing-dc</tt> (display the <a>Nothing</a> variant of
--   <a>Maybe</a> as don't-care)</li>
--   <li><tt>default-showx</tt> (use <a>ShowX</a> instead of <a>Show</a>
--   for all default implementations)</li>
--   </ul>
module Shockwaves.Viewer

-- | Class determining the appearance of a value in the waveform viewer
--   (text and color). By default, this uses <a>Show</a> and
--   <a>VKNormal</a>.
class Display a
display :: Display a => a -> (ValueRepr, ValueKind)
repr :: Display a => a -> ValueRepr
repr :: (Display a, Show a) => a -> ValueRepr
kind :: Display a => a -> ValueKind

-- | Representation of a value.
data ValueRepr

-- | Single bit
VRBit :: Char -> ValueRepr

-- | Bitvector
VRBits :: String -> ValueRepr

-- | Text
VRString :: String -> ValueRepr

-- | Signal not present; do not display signal at all
VRNotPresent :: ValueRepr

-- | Determines the way values are displayed. For most signals, this only
--   determines the color, but VIBool signals can have lines at different
--   heights for the different value types.
data ValueKind

-- | Green
VKNormal :: ValueKind

-- | Red
VKUndef :: ValueKind

-- | Yellow
VKHighImp :: ValueKind

-- | Any
VKCustom :: Color -> ValueKind

-- | Red
VKWarn :: ValueKind

-- | Blue
VKDontCare :: ValueKind

-- | Gray
VKWeak :: ValueKind

-- | Derive via <a>DisplayX</a> to use <a>ShowX</a> instead of <a>Show</a>.
newtype DisplayX a
DisplayX :: a -> DisplayX a

-- | Class for determining the structure and value of subsignals. The
--   structure can be automatically deduced for types implementing
--   <a>Generic</a> with all subtypes implementing <a>Split</a> as well.
class Split a

-- | The structure for the signal. Only VICompound types allow for
--   subsignals. In addition to the the structure of subsignals, this also
--   controls the way the current signal is displayed. Most data will be
--   shown as blocks, but boolean types are displayed as a single line that
--   can be high or low (or in between for special values).
structure :: Split a => VariableInfo

-- | The structure for the signal. Only VICompound types allow for
--   subsignals. In addition to the the structure of subsignals, this also
--   controls the way the current signal is displayed. Most data will be
--   shown as blocks, but boolean types are displayed as a single line that
--   can be high or low (or in between for special values).
structure :: forall x. (Split a, Generic a, AutoSplit (Rep a x)) => VariableInfo

-- | Function to create the data for subsignals of a given type. If
--   <a>structure</a> is not of the <a>VICompound</a> type, this list must
--   be empty. Subsignals need to share the names and order used in
--   <a>structure</a>, but not all subsignals need to be provided.
--   Subsignals that are left out will be automatically set to
--   <a>VRNotPresent</a>. The function is given a copy of the display
--   value, in case this needs to be copied.
split :: Split a => a -> (ValueRepr, ValueKind) -> [STR]

-- | Function to create the data for subsignals of a given type. If
--   <a>structure</a> is not of the <a>VICompound</a> type, this list must
--   be empty. Subsignals need to share the names and order used in
--   <a>structure</a>, but not all subsignals need to be provided.
--   Subsignals that are left out will be automatically set to
--   <a>VRNotPresent</a>. The function is given a copy of the display
--   value, in case this needs to be copied.
split :: forall x. (Split a, Generic a, AutoSplit (Rep a x)) => a -> (ValueRepr, ValueKind) -> [STR]

-- | Information about the signal structure. <a>VICompound</a> is the only
--   variant allowed to have subsignals. Translation results must match
--   this structure. <a>VIBool</a> and <a>VIClock</a> are displayed
--   differently in the waveform viewer (as waves).
data VariableInfo

-- | A signal with subsignals
VICompound :: [(String, VariableInfo)] -> VariableInfo

-- | A multiple bit signal
VIBits :: VariableInfo

-- | A 1-bit signal; displayed as a proper wave
VIBool :: VariableInfo

-- | A clock signal; displayed as a proper wave
VIClock :: VariableInfo

-- | A simple string
VIString :: VariableInfo

-- | A real number
VIReal :: VariableInfo

-- | Derive via <a>NoSplit</a> to not split a value at all.
newtype NoSplit a
NoSplit :: a -> NoSplit a

-- | A value representation similar to that used in Surfer. The structure
--   must match that of <a>VariableInfo</a>.
data TranslationResult
TranslationResult :: (ValueRepr, ValueKind) -> [SubFieldTranslationResult] -> TranslationResult

-- | A wrapper for naming compound signals.
data SubFieldTranslationResult
SubFieldTranslationResult :: String -> TranslationResult -> SubFieldTranslationResult

-- | Translate a value using <a>safeDisplay</a> and <a>safeSplit</a>. If
--   either returns <a>Nothing</a>, return a translation representing
--   undefined instead.
translate :: (Display a, Split a) => a -> TranslationResult

-- | Display a value if properly defined, else return <a>Nothing</a>.
safeDisplay :: Display a => a -> Maybe (ValueRepr, ValueKind)

-- | Split a value into values for its subsignals if properly defined, else
--   return <a>Nothing</a>.
safeSplit :: Split a => a -> (ValueRepr, ValueKind) -> [STR]

-- | Helper class for automatically deriving default <a>Split</a> instances
--   using <a>Generic</a>.
class AutoSplit a

-- | Like <a>Split</a>'s <a>structure</a>
autoStructure :: AutoSplit a => VariableInfo

-- | Like <a>Split</a>'s <a>split</a>
autoSplit :: AutoSplit a => a -> (ValueRepr, ValueKind) -> [STR]
instance Clash.XException.NFDataX Shockwaves.Viewer.ValueRepr
instance Control.DeepSeq.NFData Shockwaves.Viewer.ValueRepr
instance GHC.Generics.Generic Shockwaves.Viewer.ValueRepr
instance GHC.Show.Show Shockwaves.Viewer.ValueRepr
instance Clash.XException.NFDataX Shockwaves.Viewer.ValueKind
instance Control.DeepSeq.NFData Shockwaves.Viewer.ValueKind
instance GHC.Generics.Generic Shockwaves.Viewer.ValueKind
instance GHC.Show.Show Shockwaves.Viewer.ValueKind
instance GHC.Show.Show Shockwaves.Viewer.VariableInfo
instance Clash.XException.NFDataX Shockwaves.Viewer.TranslationResult
instance Control.DeepSeq.NFData Shockwaves.Viewer.TranslationResult
instance GHC.Generics.Generic Shockwaves.Viewer.TranslationResult
instance GHC.Show.Show Shockwaves.Viewer.TranslationResult
instance Clash.XException.NFDataX Shockwaves.Viewer.SubFieldTranslationResult
instance Control.DeepSeq.NFData Shockwaves.Viewer.SubFieldTranslationResult
instance GHC.Generics.Generic Shockwaves.Viewer.SubFieldTranslationResult
instance GHC.Show.Show Shockwaves.Viewer.SubFieldTranslationResult
instance Clash.XException.ShowX a => Clash.XException.ShowX (Shockwaves.Viewer.DisplayX a)
instance GHC.Generics.Generic (Shockwaves.Viewer.DisplayX a)
instance Shockwaves.Viewer.Split ()
instance Shockwaves.Viewer.Split GHC.Types.Char
instance Shockwaves.Viewer.Split GHC.Types.Double
instance Shockwaves.Viewer.Split GHC.Types.Float
instance Shockwaves.Viewer.Split GHC.Types.Int
instance Shockwaves.Viewer.Split GHC.Int.Int8
instance Shockwaves.Viewer.Split GHC.Int.Int16
instance Shockwaves.Viewer.Split GHC.Int.Int32
instance Shockwaves.Viewer.Split GHC.Int.Int64
instance Shockwaves.Viewer.Split GHC.Types.Ordering
instance Shockwaves.Viewer.Split GHC.Types.Word
instance Shockwaves.Viewer.Split GHC.Word.Word8
instance Shockwaves.Viewer.Split GHC.Word.Word16
instance Shockwaves.Viewer.Split GHC.Word.Word32
instance Shockwaves.Viewer.Split GHC.Word.Word64
instance Shockwaves.Viewer.Split Foreign.C.Types.CUShort
instance Shockwaves.Viewer.Split (Clash.Sized.Internal.Signed.Signed n)
instance Shockwaves.Viewer.Split (Clash.Sized.Internal.Unsigned.Unsigned n)
instance Shockwaves.Viewer.Split (Clash.Sized.Internal.Index.Index n)
instance Shockwaves.Viewer.Split (Clash.Sized.Fixed.Fixed r i f)
instance Shockwaves.Viewer.Split (Clash.Promoted.Nat.SNat n)
instance forall k (a :: k). Shockwaves.Viewer.Split (Data.Proxy.Proxy a)
instance forall k (name :: GHC.Types.Symbol) (fields :: k -> GHC.Types.Type) (p :: k) (meta :: GHC.Generics.Meta) (x :: GHC.Generics.FixityI) (y :: GHC.Types.Bool). (GHC.TypeLits.KnownSymbol name, Shockwaves.Viewer.AutoSplitFields (fields p)) => Shockwaves.Viewer.AutoSplit (GHC.Generics.D1 meta (GHC.Generics.C1 ('GHC.Generics.MetaCons name x y) fields) p)
instance forall k (name :: GHC.Types.Symbol) (fields :: k -> GHC.Types.Type) (p :: k) (x :: GHC.Generics.FixityI) (y :: GHC.Types.Bool). (GHC.TypeLits.KnownSymbol name, Shockwaves.Viewer.AutoSplitFields (fields p)) => Shockwaves.Viewer.AutoSplitConstrs (GHC.Generics.C1 ('GHC.Generics.MetaCons name x y) fields p)
instance forall k (a :: k -> GHC.Types.Type) (p :: k) (b :: k -> GHC.Types.Type). (Shockwaves.Viewer.AutoSplitFields (a p), Shockwaves.Viewer.AutoSplitFields (b p)) => Shockwaves.Viewer.AutoSplitFields ((GHC.Generics.:*:) a b p)
instance forall k (name :: GHC.Types.Symbol) a (x :: GHC.Generics.SourceUnpackedness) (y :: GHC.Generics.SourceStrictness) (z :: GHC.Generics.DecidedStrictness) (p :: k). (GHC.TypeLits.KnownSymbol name, Shockwaves.Viewer.Split a, Shockwaves.Viewer.Display a) => Shockwaves.Viewer.AutoSplitFields (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just name) x y z) (GHC.Generics.Rec0 a) p)
instance forall k a (x :: GHC.Generics.SourceUnpackedness) (y :: GHC.Generics.SourceStrictness) (z :: GHC.Generics.DecidedStrictness) (p :: k). (Shockwaves.Viewer.Split a, Shockwaves.Viewer.Display a) => Shockwaves.Viewer.AutoSplitFields (GHC.Generics.S1 ('GHC.Generics.MetaSel 'GHC.Maybe.Nothing x y z) (GHC.Generics.Rec0 a) p)
instance forall k (p :: k). Shockwaves.Viewer.AutoSplitFields (GHC.Generics.U1 p)
instance forall k (a :: k -> GHC.Types.Type) (b :: k -> GHC.Types.Type) (p :: k) (meta :: GHC.Generics.Meta). Shockwaves.Viewer.AutoSplitConstrs ((GHC.Generics.:+:) a b p) => Shockwaves.Viewer.AutoSplit (GHC.Generics.D1 meta (a GHC.Generics.:+: b) p)
instance forall k (a :: k -> GHC.Types.Type) (p :: k) (b :: k -> GHC.Types.Type). (Shockwaves.Viewer.AutoSplitConstrs (a p), Shockwaves.Viewer.AutoSplitConstrs (b p)) => Shockwaves.Viewer.AutoSplitConstrs ((GHC.Generics.:+:) a b p)
instance Shockwaves.Viewer.Split (Shockwaves.Viewer.NoSplit a)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1) => Shockwaves.Viewer.Split (a0, a1)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2) => Shockwaves.Viewer.Split (a0, a1, a2)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3) => Shockwaves.Viewer.Split (a0, a1, a2, a3)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6, Shockwaves.Viewer.Display a7, Shockwaves.Viewer.Split a7) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6, a7)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6, Shockwaves.Viewer.Display a7, Shockwaves.Viewer.Split a7, Shockwaves.Viewer.Display a8, Shockwaves.Viewer.Split a8) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6, a7, a8)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6, Shockwaves.Viewer.Display a7, Shockwaves.Viewer.Split a7, Shockwaves.Viewer.Display a8, Shockwaves.Viewer.Split a8, Shockwaves.Viewer.Display a9, Shockwaves.Viewer.Split a9) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6, Shockwaves.Viewer.Display a7, Shockwaves.Viewer.Split a7, Shockwaves.Viewer.Display a8, Shockwaves.Viewer.Split a8, Shockwaves.Viewer.Display a9, Shockwaves.Viewer.Split a9, Shockwaves.Viewer.Display a10, Shockwaves.Viewer.Split a10) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6, Shockwaves.Viewer.Display a7, Shockwaves.Viewer.Split a7, Shockwaves.Viewer.Display a8, Shockwaves.Viewer.Split a8, Shockwaves.Viewer.Display a9, Shockwaves.Viewer.Split a9, Shockwaves.Viewer.Display a10, Shockwaves.Viewer.Split a10, Shockwaves.Viewer.Display a11, Shockwaves.Viewer.Split a11) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6, Shockwaves.Viewer.Display a7, Shockwaves.Viewer.Split a7, Shockwaves.Viewer.Display a8, Shockwaves.Viewer.Split a8, Shockwaves.Viewer.Display a9, Shockwaves.Viewer.Split a9, Shockwaves.Viewer.Display a10, Shockwaves.Viewer.Split a10, Shockwaves.Viewer.Display a11, Shockwaves.Viewer.Split a11, Shockwaves.Viewer.Display a12, Shockwaves.Viewer.Split a12) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6, Shockwaves.Viewer.Display a7, Shockwaves.Viewer.Split a7, Shockwaves.Viewer.Display a8, Shockwaves.Viewer.Split a8, Shockwaves.Viewer.Display a9, Shockwaves.Viewer.Split a9, Shockwaves.Viewer.Display a10, Shockwaves.Viewer.Split a10, Shockwaves.Viewer.Display a11, Shockwaves.Viewer.Split a11, Shockwaves.Viewer.Display a12, Shockwaves.Viewer.Split a12, Shockwaves.Viewer.Display a13, Shockwaves.Viewer.Split a13) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
instance (Shockwaves.Viewer.Display a0, Shockwaves.Viewer.Split a0, Shockwaves.Viewer.Display a1, Shockwaves.Viewer.Split a1, Shockwaves.Viewer.Display a2, Shockwaves.Viewer.Split a2, Shockwaves.Viewer.Display a3, Shockwaves.Viewer.Split a3, Shockwaves.Viewer.Display a4, Shockwaves.Viewer.Split a4, Shockwaves.Viewer.Display a5, Shockwaves.Viewer.Split a5, Shockwaves.Viewer.Display a6, Shockwaves.Viewer.Split a6, Shockwaves.Viewer.Display a7, Shockwaves.Viewer.Split a7, Shockwaves.Viewer.Display a8, Shockwaves.Viewer.Split a8, Shockwaves.Viewer.Display a9, Shockwaves.Viewer.Split a9, Shockwaves.Viewer.Display a10, Shockwaves.Viewer.Split a10, Shockwaves.Viewer.Display a11, Shockwaves.Viewer.Split a11, Shockwaves.Viewer.Display a12, Shockwaves.Viewer.Split a12, Shockwaves.Viewer.Display a13, Shockwaves.Viewer.Split a13, Shockwaves.Viewer.Display a14, Shockwaves.Viewer.Split a14) => Shockwaves.Viewer.Split (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)
instance Shockwaves.Viewer.Split GHC.Types.Bool
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (GHC.Maybe.Maybe a)
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a, Shockwaves.Viewer.Display b, Shockwaves.Viewer.Split b) => Shockwaves.Viewer.Split (Data.Either.Either a b)
instance Shockwaves.Viewer.Split Clash.Sized.Internal.BitVector.Bit
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Data.Complex.Complex a)
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Data.Ord.Down a)
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Data.Functor.Identity.Identity a)
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Clash.Num.Zeroing.Zeroing a)
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Clash.Num.Wrapping.Wrapping a)
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Clash.Num.Saturating.Saturating a)
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Clash.Num.Overflowing.Overflowing a)
instance (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Clash.Num.Erroring.Erroring a)
instance (GHC.TypeNats.KnownNat n, Shockwaves.Viewer.Split a, Shockwaves.Viewer.Display a) => Shockwaves.Viewer.Split (Clash.Sized.Vector.Vec n a)
instance (GHC.Show.Show a, Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a, GHC.TypeNats.KnownNat d) => Shockwaves.Viewer.Split (Clash.Sized.RTree.RTree d a)
instance GHC.TypeNats.KnownNat n => Shockwaves.Viewer.Split (Clash.Sized.Internal.BitVector.BitVector n)
instance forall k a (b :: k). (Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.Viewer.Split (Data.Functor.Const.Const a b)
instance forall k (f :: k -> GHC.Types.Type) (a :: k) (g :: k -> GHC.Types.Type). (Shockwaves.Viewer.Display (f a), Shockwaves.Viewer.Display (g a), Shockwaves.Viewer.Split (f a), Shockwaves.Viewer.Split (g a)) => Shockwaves.Viewer.Split (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> GHC.Types.Type) (a :: k) (g :: k -> GHC.Types.Type). (Shockwaves.Viewer.Display (f a), Shockwaves.Viewer.Display (g a), Shockwaves.Viewer.Split (f a), Shockwaves.Viewer.Split (g a)) => Shockwaves.Viewer.Split (Data.Functor.Sum.Sum f g a)
instance forall k1 (f :: GHC.Types.Type -> GHC.Types.Type) (g :: k1 -> GHC.Types.Type) (a :: k1). (Shockwaves.Viewer.Display (f (g a)), Shockwaves.Viewer.Display (g a), Shockwaves.Viewer.Split (f (g a)), Shockwaves.Viewer.Split (g a)) => Shockwaves.Viewer.Split (Data.Functor.Compose.Compose f g a)
instance Clash.XException.ShowX a => Shockwaves.Viewer.Display (Shockwaves.Viewer.DisplayX a)
instance (GHC.Show.Show a0, GHC.Show.Show a1) => Shockwaves.Viewer.Display (a0, a1)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2) => Shockwaves.Viewer.Display (a0, a1, a2)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3) => Shockwaves.Viewer.Display (a0, a1, a2, a3)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6, a7)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6, a7, a8)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8, GHC.Show.Show a9) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8, GHC.Show.Show a9, GHC.Show.Show a10) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8, GHC.Show.Show a9, GHC.Show.Show a10, GHC.Show.Show a11) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8, GHC.Show.Show a9, GHC.Show.Show a10, GHC.Show.Show a11, GHC.Show.Show a12) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8, GHC.Show.Show a9, GHC.Show.Show a10, GHC.Show.Show a11, GHC.Show.Show a12, GHC.Show.Show a13) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
instance (GHC.Show.Show a0, GHC.Show.Show a1, GHC.Show.Show a2, GHC.Show.Show a3, GHC.Show.Show a4, GHC.Show.Show a5, GHC.Show.Show a6, GHC.Show.Show a7, GHC.Show.Show a8, GHC.Show.Show a9, GHC.Show.Show a10, GHC.Show.Show a11, GHC.Show.Show a12, GHC.Show.Show a13, GHC.Show.Show a14) => Shockwaves.Viewer.Display (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)
instance Shockwaves.Viewer.Display ()
instance Shockwaves.Viewer.Display GHC.Types.Bool
instance GHC.Show.Show a => Shockwaves.Viewer.Display (GHC.Maybe.Maybe a)
instance (GHC.Show.Show a, GHC.Show.Show b) => Shockwaves.Viewer.Display (Data.Either.Either a b)
instance Shockwaves.Viewer.Display GHC.Types.Char
instance Shockwaves.Viewer.Display Clash.Sized.Internal.BitVector.Bit
instance Shockwaves.Viewer.Display GHC.Types.Double
instance Shockwaves.Viewer.Display GHC.Types.Float
instance Shockwaves.Viewer.Display GHC.Types.Int
instance Shockwaves.Viewer.Display GHC.Int.Int8
instance Shockwaves.Viewer.Display GHC.Int.Int16
instance Shockwaves.Viewer.Display GHC.Int.Int32
instance Shockwaves.Viewer.Display GHC.Int.Int64
instance Shockwaves.Viewer.Display GHC.Types.Ordering
instance Shockwaves.Viewer.Display GHC.Types.Word
instance Shockwaves.Viewer.Display GHC.Word.Word8
instance Shockwaves.Viewer.Display GHC.Word.Word16
instance Shockwaves.Viewer.Display GHC.Word.Word32
instance Shockwaves.Viewer.Display GHC.Word.Word64
instance Shockwaves.Viewer.Display Foreign.C.Types.CUShort
instance Shockwaves.Viewer.Display (Clash.Sized.Internal.Signed.Signed n)
instance Shockwaves.Viewer.Display (Clash.Sized.Internal.Unsigned.Unsigned n)
instance Shockwaves.Viewer.Display (Clash.Sized.Internal.Index.Index n)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Data.Complex.Complex a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Data.Ord.Down a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Data.Functor.Identity.Identity a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Clash.Num.Zeroing.Zeroing a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Clash.Num.Wrapping.Wrapping a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Clash.Num.Saturating.Saturating a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Clash.Num.Overflowing.Overflowing a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Clash.Num.Erroring.Erroring a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Clash.Sized.Vector.Vec n a)
instance GHC.Show.Show a => Shockwaves.Viewer.Display (Clash.Sized.RTree.RTree d a)
instance GHC.TypeNats.KnownNat n => Shockwaves.Viewer.Display (Clash.Sized.Internal.BitVector.BitVector n)
instance forall k a (b :: k). GHC.Show.Show a => Shockwaves.Viewer.Display (Data.Functor.Const.Const a b)
instance GHC.Show.Show (Clash.Sized.Fixed.Fixed r i f) => Shockwaves.Viewer.Display (Clash.Sized.Fixed.Fixed r i f)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => Shockwaves.Viewer.Display (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => Shockwaves.Viewer.Display (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => Shockwaves.Viewer.Display (Data.Functor.Compose.Compose f g a)
instance Shockwaves.Viewer.Display (Clash.Promoted.Nat.SNat n)
instance forall k (a :: k). Shockwaves.Viewer.Display (Data.Proxy.Proxy a)


-- | Module for translating translation information to Surfer-friendly JSON
--   format.
module Shockwaves.JSON

-- | Simple class for turning translation object into JSON.
class ToJSON a
toJSON :: ToJSON a => a -> String
instance Shockwaves.JSON.ToJSON GHC.Base.String
instance Shockwaves.JSON.ToJSON Shockwaves.Viewer.TranslationResult
instance Shockwaves.JSON.ToJSON Shockwaves.Viewer.ValueRepr
instance Shockwaves.JSON.ToJSON Shockwaves.Viewer.ValueKind
instance Shockwaves.JSON.ToJSON Shockwaves.Color.Color
instance Shockwaves.JSON.ToJSON [Shockwaves.Viewer.SubFieldTranslationResult]
instance Shockwaves.JSON.ToJSON [(GHC.Base.String, Shockwaves.Viewer.VariableInfo)]
instance Shockwaves.JSON.ToJSON Shockwaves.Viewer.SubFieldTranslationResult
instance Shockwaves.JSON.ToJSON Shockwaves.Viewer.VariableInfo
instance Shockwaves.JSON.ToJSON (GHC.Base.String, Shockwaves.Viewer.VariableInfo)
instance Shockwaves.JSON.ToJSON a => Shockwaves.JSON.ToJSON (Shockwaves.Viewer.VariableInfo, a)
instance Shockwaves.JSON.ToJSON a => Shockwaves.JSON.ToJSON (Data.Map.Internal.Map GHC.Base.String a)


-- | <a>Trace</a>, adapted for use with Shockwaves. Example usage:
--   
--   <pre>
--   import Clash.Prelude hiding (writeFile)
--   import Data.Text.IO  (writeFile)
--   import qualified Shockwaves.Trace as SWT
--   
--   -- | Count and wrap around
--   subCounter :: SystemClockResetEnable =&gt; Signal System (Index 3)
--   subCounter = SWT.traceSignal1 "sub" counter
--     where
--       counter =
--         register 0 (fmap succ' counter)
--   
--       succ' c
--         | c == maxBound = 0
--         | otherwise     = c + 1
--   
--   -- | Count, but only when my subcounter is wrapping around
--   mainCounter :: SystemClockResetEnable =&gt; Signal System (Signed 64)
--   mainCounter = SWT.traceSignal1 "main" counter
--     where
--       counter =
--         register 0 (fmap succ' $ bundle (subCounter,counter))
--   
--       succ' (sc, c)
--         | sc == maxBound = c + 1
--         | otherwise      = c
--   
--   -- | Collect traces, and dump them to a VCD file.
--   main :: IO ()
--   main = do
--     let cntrOut = exposeClockResetEnable mainCounter systemClockGen systemResetGen enableGen
--     vcddata &lt;- SWT.dumpVCD (0, 100) cntrOut ["main", "sub"]
--     case vcd of
--       Left msg -&gt;
--         error msg
--       Right (vcd,types,trans) -&gt;
--         do writeFile "mainCounter.vcd" $ Text.unpack vcd
--            writeFile "mainCounter.types.json" $ Text.unpack types
--            writeFile "mainCounter.trans.json" $ Text.unpack trans
--   </pre>
module Shockwaves.Trace

-- | Trace a single signal. Will emit an error if a signal with the same
--   name was previously registered.
--   
--   <b>NB</b>: Associates the traced signal with a clock period of
--   <i>1</i>, which results in incorrect VCD files when working with
--   circuits that have multiple clocks. Use <a>traceSignal</a> when
--   working with circuits that have multiple clocks.
traceSignal1 :: (BitPack a, NFDataX a, Typeable a, Split a, Display a) => String -> Signal dom a -> Signal dom a

-- | Trace a single vector signal: each element in the vector will show up
--   as a different trace. If the trace name already exists, this function
--   will emit an error.
--   
--   <b>NB</b>: Associates the traced signal with a clock period of
--   <i>1</i>, which results in incorrect VCD files when working with
--   circuits that have multiple clocks. Use <a>traceSignal</a> when
--   working with circuits that have multiple clocks.
traceVecSignal1 :: (KnownNat n, BitPack a, NFDataX a, Typeable a, Split a, Display a) => String -> Signal dom (Vec (n + 1) a) -> Signal dom (Vec (n + 1) a)

-- | Trace a single signal. Will emit an error if a signal with the same
--   name was previously registered.
--   
--   <b>NB</b>: Works correctly when creating VCD files from traced signal
--   in multi-clock circuits. However <a>traceSignal1</a> might be more
--   convenient to use when the domain of your circuit is polymorphic.
traceSignal :: forall dom a. (KnownDomain dom, BitPack a, NFDataX a, Typeable a, Split a, Display a) => String -> Signal dom a -> Signal dom a

-- | Trace a single vector signal: each element in the vector will show up
--   as a different trace. If the trace name already exists, this function
--   will emit an error.
--   
--   <b>NB</b>: Works correctly when creating VCD files from traced signal
--   in multi-clock circuits. However <a>traceSignal1</a> might be more
--   convenient to use when the domain of your circuit is polymorphic.
traceVecSignal :: forall dom a n. (KnownDomain dom, KnownNat n, BitPack a, NFDataX a, Typeable a, Split a, Display a) => String -> Signal dom (Vec (n + 1) a) -> Signal dom (Vec (n + 1) a)

-- | Produce a four-state VCD (Value Change Dump) according to IEEE
--   1364-{1995,2001}, as well as a signal-to-type table and a value
--   translation table. This function fails if a trace name contains either
--   non-printable or non-VCD characters.
--   
--   Due to lazy evaluation, the created VCD files might not contain all
--   the traces you were expecting. You therefore have to provide a list of
--   names you definately want to be dumped in the VCD file.
--   
--   For example:
--   
--   <pre>
--   vcd &lt;- dumpVCD (0, 100) cntrOut ["main", "sub"]
--   </pre>
--   
--   Evaluates <i>cntrOut</i> long enough in order for to guarantee that
--   the <tt>main</tt>, and <tt>sub</tt> traces end up in the generated VCD
--   file.
dumpVCD :: NFDataX a => Split a => (Int, Int) -> Signal dom a -> [String] -> IO (Either String (Text, Text, Text))

-- | Dump a number of samples to a replayable bytestring.
dumpReplayable :: forall a dom. (NFDataX a, Split a) => Int -> Signal dom a -> String -> IO ByteString

-- | Take a serialized signal (dumped with <tt>dumpReplayable</tt>) and
--   convert it back into a signal. Will error if dumped type does not
--   match requested type. The first value in the signal that fails to
--   decode will stop the decoding process and yield an error. Not that
--   this always happens if you evaluate more values than were originally
--   dumped.
replay :: forall a dom n. (Typeable a, NFDataX a, BitPack a, KnownNat n, n ~ BitSize a) => ByteString -> Either String (Signal dom a)
type Period = Int
type Changed = Bool
type Value = (Natural, Natural)
type Width = Int
type TraceMap = Map String (TypeRepBS, String, VariableInfo, Period, Width, [(Value, String, TranslationResult)])

-- | Serialized TypeRep we need to store for dumpReplayable / replay
type TypeRepBS = ByteString

-- | Trace a single signal. Will emit an error if a signal with the same
--   name was previously registered.
traceSignal# :: forall dom a. (BitPack a, NFDataX a, Typeable a, Split a, Display a) => IORef TraceMap -> Int -> String -> Signal dom a -> IO (Signal dom a)

-- | Trace a single vector signal: each element in the vector will show up
--   as a different trace. If the trace name already exists, this function
--   will emit an error.
traceVecSignal# :: forall dom n a. (KnownNat n, BitPack a, NFDataX a, Typeable a, Split a, Display a) => IORef TraceMap -> Int -> String -> Signal dom (Vec (n + 1) a) -> IO (Signal dom (Vec (n + 1) a))

-- | Same as <tt>dumpVCD</tt>, but supplied with a custom tracemap
dumpVCD# :: NFDataX a => IORef TraceMap -> (Int, Int) -> Signal dom a -> [String] -> IO (Either String (Text, Text, Text))

-- | Same as <tt>dumpVCD</tt>, but supplied with a custom tracemap and a
--   custom timestamp
dumpVCD## :: (Int, Int) -> TraceMap -> UTCTime -> Either String (Text, Text, Text)

-- | Keep evaluating given signal until all trace names are present.
waitForTraces# :: NFDataX a => IORef TraceMap -> Signal dom a -> [String] -> IO ()

-- | Map of traces used by the non-internal trace and dumpvcd functions.
traceMap# :: IORef TraceMap
instance GHC.TypeNats.KnownNat n => Shockwaves.Trace.ShowSimple (Clash.Sized.Internal.BitVector.BitVector n)


-- | Module for translating values after simulation (i.e. when not using
--   <a>Trace</a>). This module is mostly useful for experimentation.
module Shockwaves.PostTranslation

-- | Generate a table of value representations for types, using the
--   provided type-label-to-functions table, and the list of (type label,
--   list of values) pairs.
genTable :: (String -> (StructF, TransF)) -> [(String, [String])] -> TranslationTable
type StructF = -- | StructF is treated as a function returning the variable info. VariableInfo
type TransF = -- | Function translating a string of bits into a `TranslationResult`. (String -> TranslationResult)

-- | Table holding for each type label the structure of the type, and the
--   translations of some values.
type TranslationTable = Map String (VariableInfo, Map String TranslationResult)

-- | Get translation function for a given type. This class is used to only
--   have to specify the type once while translating.
class TypeFunctions a

-- | Get translation function for the type.
tf :: TypeFunctions a => (StructF, TransF)

-- | Given a function to convert type strings into translation functions
--   for that type, turn the values per type from the input file into a
--   translation table.
translateFile :: (String -> (StructF, TransF)) -> String -> String -> IO ()

-- | Given a function that maps string representations of types to the
--   translation functions for said type, translate all values in the input
--   file. Run <a>translateFile</a> using the first two command line
--   arguments for the input and output. The input file format is:
--   
--   <pre>
--   &lt;type&gt;
--   &lt;value&gt; &lt;value&gt; &lt;value&gt; ...
--   &lt;type&gt;
--   ...
--   </pre>
translateCmdLine :: (String -> (StructF, TransF)) -> IO ()
instance (Clash.Class.BitPack.Internal.BitPack a, Shockwaves.Viewer.Display a, Shockwaves.Viewer.Split a) => Shockwaves.PostTranslation.TypeFunctions a

module Shockwaves

-- | Class determining the appearance of a value in the waveform viewer
--   (text and color). By default, this uses <a>Show</a> and
--   <a>VKNormal</a>.
class Display a
display :: Display a => a -> (ValueRepr, ValueKind)
repr :: Display a => a -> ValueRepr
repr :: (Display a, Show a) => a -> ValueRepr
kind :: Display a => a -> ValueKind

-- | Representation of a value.
data ValueRepr

-- | Single bit
VRBit :: Char -> ValueRepr

-- | Bitvector
VRBits :: String -> ValueRepr

-- | Text
VRString :: String -> ValueRepr

-- | Signal not present; do not display signal at all
VRNotPresent :: ValueRepr

-- | Determines the way values are displayed. For most signals, this only
--   determines the color, but VIBool signals can have lines at different
--   heights for the different value types.
data ValueKind

-- | Green
VKNormal :: ValueKind

-- | Red
VKUndef :: ValueKind

-- | Yellow
VKHighImp :: ValueKind

-- | Any
VKCustom :: Color -> ValueKind

-- | Red
VKWarn :: ValueKind

-- | Blue
VKDontCare :: ValueKind

-- | Gray
VKWeak :: ValueKind

-- | Class for determining the structure and value of subsignals. The
--   structure can be automatically deduced for types implementing
--   <a>Generic</a> with all subtypes implementing <a>Split</a> as well.
class Split a

-- | The structure for the signal. Only VICompound types allow for
--   subsignals. In addition to the the structure of subsignals, this also
--   controls the way the current signal is displayed. Most data will be
--   shown as blocks, but boolean types are displayed as a single line that
--   can be high or low (or in between for special values).
structure :: Split a => VariableInfo

-- | The structure for the signal. Only VICompound types allow for
--   subsignals. In addition to the the structure of subsignals, this also
--   controls the way the current signal is displayed. Most data will be
--   shown as blocks, but boolean types are displayed as a single line that
--   can be high or low (or in between for special values).
structure :: forall x. (Split a, Generic a, AutoSplit (Rep a x)) => VariableInfo

-- | Function to create the data for subsignals of a given type. If
--   <a>structure</a> is not of the <a>VICompound</a> type, this list must
--   be empty. Subsignals need to share the names and order used in
--   <a>structure</a>, but not all subsignals need to be provided.
--   Subsignals that are left out will be automatically set to
--   <a>VRNotPresent</a>. The function is given a copy of the display
--   value, in case this needs to be copied.
split :: Split a => a -> (ValueRepr, ValueKind) -> [STR]

-- | Function to create the data for subsignals of a given type. If
--   <a>structure</a> is not of the <a>VICompound</a> type, this list must
--   be empty. Subsignals need to share the names and order used in
--   <a>structure</a>, but not all subsignals need to be provided.
--   Subsignals that are left out will be automatically set to
--   <a>VRNotPresent</a>. The function is given a copy of the display
--   value, in case this needs to be copied.
split :: forall x. (Split a, Generic a, AutoSplit (Rep a x)) => a -> (ValueRepr, ValueKind) -> [STR]

-- | Information about the signal structure. <a>VICompound</a> is the only
--   variant allowed to have subsignals. Translation results must match
--   this structure. <a>VIBool</a> and <a>VIClock</a> are displayed
--   differently in the waveform viewer (as waves).
data VariableInfo

-- | A signal with subsignals
VICompound :: [(String, VariableInfo)] -> VariableInfo

-- | A multiple bit signal
VIBits :: VariableInfo

-- | A 1-bit signal; displayed as a proper wave
VIBool :: VariableInfo

-- | A clock signal; displayed as a proper wave
VIClock :: VariableInfo

-- | A simple string
VIString :: VariableInfo

-- | A real number
VIReal :: VariableInfo

-- | Translate a value using <a>safeDisplay</a> and <a>safeSplit</a>. If
--   either returns <a>Nothing</a>, return a translation representing
--   undefined instead.
translate :: (Display a, Split a) => a -> TranslationResult
